from flask import Blueprint, jsonify, request, session, current_app
from src.models.user import User, db
from src.models.ticket import Ticket
from src.models.status import Status
from src.routes.user import login_required, admin_required
from functools import wraps
from telegram_notify import send_telegram_message
import os
import mimetypes
import uuid
from werkzeug.utils import secure_filename
from PIL import Image

ticket_bp = Blueprint('ticket', __name__)

ALLOWED_EXTENSIONS = {
    'image/jpeg': ['.jpg', '.jpeg'],
    'image/png': ['.png'],
    'image/gif': ['.gif'],
    'application/pdf': ['.pdf'],
    'text/plain': ['.txt']
}

MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB

def allowed_file(file):
    if not file or not file.filename:
        return False

    filename = secure_filename(file.filename)
    extension = os.path.splitext(filename)[1].lower()
    mime_type = mimetypes.guess_type(filename)[0]
    
    # Check file size
    file.seek(0, 2)  # Go to end of file
    size = file.tell()
    file.seek(0)  # Reset file position
    
    if size > MAX_FILE_SIZE:
        return False
    
    if mime_type not in ALLOWED_EXTENSIONS:
        return False
        
    if extension not in ALLOWED_EXTENSIONS[mime_type]:
        return False
        
    # Additional security check for images
    if mime_type and mime_type.startswith('image/'):
        try:
            with Image.open(file) as img:
                img.verify()
                file.seek(0)  # Reset file position after verify
                return True
        except Exception:
            return False
            
    return True

def save_file(file, ticket_id):
    if not file:
        return None
          try:
        filename = secure_filename(file.filename)
        # Генерируем уникальное имя файла
        unique_filename = f"{uuid.uuid4()}_{filename}"
        
        # Создаем папку для файлов заявки, если её нет
        upload_folder = os.path.join(current_app.config['UPLOAD_FOLDER'], str(ticket_id))
        os.makedirs(upload_folder, exist_ok=True)
        
        file_path = os.path.join(upload_folder, unique_filename)
        
        # Для изображений делаем обработку
        mime_type = mimetypes.guess_type(filename)[0]
        if mime_type and mime_type.startswith('image/'):
            img = Image.open(file)
            # Convert to RGB if image is in RGBA mode
            if img.mode == 'RGBA':
                bg = Image.new('RGB', img.size, 'white')
                bg.paste(img, mask=img.split()[3])
                img = bg
            elif img.mode not in ['RGB', 'L']:
                img = img.convert('RGB')
                  # Max dimensions for thumbnail
            MAX_SIZE = (1920, 1920)
            img.thumbnail(MAX_SIZE, Image.LANCZOS)
            
            # Optimize based on format
            format_options = {
                'JPEG': {'format': 'JPEG', 'quality': 85, 'optimize': True},
                'PNG': {'format': 'PNG', 'optimize': True},
                'GIF': {'format': 'GIF', 'optimize': True}
            }
            
            format_name = img.format or 'JPEG'
            save_options = format_options.get(format_name, format_options['JPEG'])
            img.save(file_path, **save_options)
        else:
            file.save(file_path)
            
        return unique_filename
    except Exception as e:
        print(f"Error saving file: {e}")
        return None

def agent_or_admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({'error': 'Authentication required'}), 401
        user = User.query.get(session['user_id'])
        if not user or user.role not in ['admin', 'agent']:
            return jsonify({'error': 'Agent or admin access required'}), 403
        return f(*args, **kwargs)
    return decorated_function

@ticket_bp.route('/tickets', methods=['POST'])
@login_required
def create_ticket():
    user = User.query.get(session['user_id'])
    
    # Only customers can create tickets
    if user.role != 'customer':
        return jsonify({'error': 'Only customers can create tickets'}), 403
    
    # Get "Pending Moderation" status
    pending_status = Status.query.filter_by(name='Pending Moderation').first()
    if not pending_status:
        return jsonify({'error': 'Pending Moderation status not found'}), 500
    
    title = request.form.get('title')
    description = request.form.get('description')
    priority = request.form.get('priority', 'Medium')
    
    if not title or not description:
        return jsonify({'error': 'Title and description are required'}), 400
    
    ticket = Ticket(
        customer_id=user.id,
        title=title,
        description=description,
        priority=priority,
        status_id=pending_status.id
    )
    db.session.add(ticket)
    db.session.flush()  # Получаем ID заявки до коммита
      # Обработка вложений
    files = request.files.getlist('attachments')
    attachments = []
    errors = []
    
    for file in files:
        if not file or not file.filename:
            continue
            
        if not allowed_file(file):
            errors.append(f"File '{file.filename}' is not allowed. Supported formats: JPG, PNG, GIF, PDF, TXT (max 5MB)")
            continue
            
        filename = save_file(file, ticket.id)
        if filename:
            attachments.append(filename)
        else:
            errors.append(f"Failed to save file '{file.filename}'")
                
    if errors:
        return jsonify({'error': '\n'.join(errors)}), 400
                
    if attachments:
        ticket.attachments = attachments
    
    db.session.commit()
    
    # Формируем расширенное уведомление
    customer_name = user.username
    customer_email = user.email
    company = getattr(user, 'company', None) or 'Не указана'
    
    attachments_text = ""
    if attachments:
        attachments_text = "\n\nПрикрепленные файлы:\n" + "\n".join(attachments)
    
    msg = f"<b>Новая заявка #{ticket.id}</b>\n" \
        f"Заказчик: {customer_name}\n" \
        f"Email: {customer_email}\n" \
        f"Компания: {company}\n" \
        f"Приоритет: {ticket.priority}\n" \
        f"Заголовок: {ticket.title}\n" \
        f"Описание: {ticket.description}" \
        f"{attachments_text}"

    send_telegram_message(msg)
    
    return jsonify({
        'message': 'Ticket created successfully',
        'ticket_id': ticket.id
    }), 201

@ticket_bp.route('/tickets', methods=['GET'])
@login_required
def get_tickets():
    user = User.query.get(session['user_id'])
    
    # Build query based on user role
    if user.role == 'customer':
        # Customers see only their tickets
        tickets = Ticket.query.filter_by(customer_id=user.id)
    elif user.role == 'agent':
        # Agents see tickets assigned to them or unassigned tickets
        tickets = Ticket.query.filter(
            (Ticket.agent_id == user.id) | (Ticket.agent_id == None)
        )
    else:  # admin
        # Admins see all tickets
        tickets = Ticket.query
    
    # Apply filters
    status_filter = request.args.get('status')
    priority_filter = request.args.get('priority')
    agent_filter = request.args.get('agent_id')
    
    if status_filter:
        status = Status.query.filter_by(name=status_filter).first()
        if status:
            tickets = tickets.filter_by(status_id=status.id)
    
    if priority_filter:
        tickets = tickets.filter_by(priority=priority_filter)
    
    if agent_filter and user.role == 'admin':
        tickets = tickets.filter_by(agent_id=agent_filter)
    
    # Order by creation date (newest first)
    tickets = tickets.order_by(Ticket.created_at.desc()).all()
    
    return jsonify([ticket.to_dict() for ticket in tickets])

@ticket_bp.route('/tickets/<int:ticket_id>', methods=['GET'])
@login_required
def get_ticket(ticket_id):
    user = User.query.get(session['user_id'])
    ticket = Ticket.query.get_or_404(ticket_id)
    
    # Check access permissions
    if user.role == 'customer' and ticket.customer_id != user.id:
        return jsonify({'error': 'Access denied'}), 403
    elif user.role == 'agent' and ticket.agent_id != user.id and ticket.agent_id is not None:
        return jsonify({'error': 'Access denied'}), 403
    
    return jsonify(ticket.to_dict(include_messages=True))

@ticket_bp.route('/tickets/<int:ticket_id>/assign', methods=['PUT'])
@admin_required
def assign_ticket(ticket_id):
    data = request.json
    ticket = Ticket.query.get_or_404(ticket_id)
    agent = User.query.get_or_404(data['agent_id'])
    
    if agent.role != 'agent':
        return jsonify({'error': 'User is not an agent'}), 400
    
    ticket.agent_id = agent.id
    
    # Update status to "In Progress"
    in_progress_status = Status.query.filter_by(name='In Progress').first()
    if in_progress_status:
        ticket.status_id = in_progress_status.id
    
    db.session.commit()
    
    # Уведомление о назначении исполнителя
    msg = f"<b>Заявка #{ticket.id}</b> назначена исполнителю: <b>{agent.username}</b>"
    send_telegram_message(msg)
    
    return jsonify(ticket.to_dict())

@ticket_bp.route('/tickets/<int:ticket_id>/status', methods=['PUT'])
@agent_or_admin_required
def update_ticket_status(ticket_id):
    data = request.json
    ticket = Ticket.query.get_or_404(ticket_id)
    user = User.query.get(session['user_id'])
    
    # Check if agent is assigned to this ticket
    if user.role == 'agent' and ticket.agent_id != user.id:
        return jsonify({'error': 'Access denied'}), 403
    
    old_status = ticket.status.name if ticket.status else ''
    new_status = Status.query.filter_by(name=data['status']).first()
    if not new_status:
        return jsonify({'error': 'Invalid status'}), 400
    
    ticket.status_id = new_status.id
    
    # If closing ticket, set closed_at
    if data['status'] == 'Closed':
        from datetime import datetime
        ticket.closed_at = datetime.utcnow()
    
    db.session.commit()
    
    # Уведомление о закрытии заявки
    if data['status'] == 'Closed':
        msg = f"<b>Заявка #{ticket.id}</b> закрыта!"\
              f"\nТема: {ticket.title}"
        send_telegram_message(msg)
    
    return jsonify(ticket.to_dict())

@ticket_bp.route('/tickets/<int:ticket_id>/priority', methods=['PUT'])
@admin_required
def update_ticket_priority(ticket_id):
    data = request.json
    ticket = Ticket.query.get_or_404(ticket_id)
    
    valid_priorities = ['Low', 'Medium', 'High', 'Critical']
    if data['priority'] not in valid_priorities:
        return jsonify({'error': 'Invalid priority'}), 400
    
    ticket.priority = data['priority']
    db.session.commit()
    
    return jsonify(ticket.to_dict())

@ticket_bp.route('/tickets/stats', methods=['GET'])
@login_required
def ticket_stats():
    user = User.query.get(session['user_id'])
    query = Ticket.query
    if user.role == 'agent':
        query = query.filter_by(agent_id=user.id)
    elif user.role == 'customer':
        query = query.filter_by(customer_id=user.id)
    tickets = query.all()
    def count_status(name):
        status = Status.query.filter_by(name=name).first()
        if not status:
            return 0
        return sum(1 for t in tickets if t.status_id == status.id)
    return jsonify({
        'total': len(tickets),
        'pending_moderation': count_status('Pending Moderation'),
        'open': count_status('Open'),
        'in_progress': count_status('In Progress'),
        'awaiting_customer': count_status('Awaiting Customer Reply'),
        'awaiting_agent': count_status('Awaiting Agent Reply'),
        'resolved': count_status('Resolved'),
        'closed': count_status('Closed'),
    })

